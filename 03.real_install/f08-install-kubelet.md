# 安装kubectl

## 一、创建角色资源

```bash
mkdir /opt/kubernetes/conf
cat > bootstrap.secret.yaml << EOF 
apiVersion: v1
kind: Secret
metadata:
  name: bootstrap-token-c8ad9c
  namespace: kube-system
type: bootstrap.kubernetes.io/token
stringData:
  description: "The default bootstrap token generated by 'kubelet '."
  token-id: c8ad9c
  token-secret: 2e4d610cf3e7426e
  usage-bootstrap-authentication: "true"
  usage-bootstrap-signing: "true"
  auth-extra-groups:  system:bootstrappers:default-node-token,system:bootstrappers:worker,system:bootstrappers:ingress
 
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kubelet-bootstrap
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:node-bootstrapper
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:bootstrappers:default-node-token
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: node-autoapprove-bootstrap
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:bootstrappers:default-node-token
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: node-autoapprove-certificate-rotation
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:nodes
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kube-apiserver-to-kubelet
rules:
  - apiGroups:
      - ""
    resources:
      - nodes/proxy
      - nodes/stats
      - nodes/log
      - nodes/spec
      - nodes/metrics
    verbs:
      - "*"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system:kube-apiserver
  namespace: ""
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-apiserver-to-kubelet
subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: kube-apiserver
EOF
```

创建资源

```bash
kubectl create -f bootstrap.secret.yaml
```

## 二、创建kubelet用户

```bash
kubectl config set-cluster kubernetes \
--certificate-authority=/opt/certs/ca.pem \
--embed-certs=true     --server=https://192.168.9.190:7443 \
--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config set-credentials tls-bootstrap-token-user \
--token=c8ad9c.2e4d610cf3e7426e \
--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config set-context tls-bootstrap-token-user@kubernetes \
--cluster=kubernetes \
--user=tls-bootstrap-token-user \
--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config use-context tls-bootstrap-token-user@kubernetes \
--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
```

## 三、配置kubelet启动脚本

接下来在`192-debian`和`160-debian`上启动kubelet，在让kubelet启动之前，我们需要有一个基础的pause镜像，以下是拉取命令，该镜像负责其k8s集群中pod启动之前的初始化操作

```shell
docker pull kubernetes/pause
```


创建kubelet的启动脚本文件`/opt/kubernetes/server/bin/kubelet.sh`文件，添加以下内容

```shell
#!/bin/bash
./kubelet \
  --anonymous-auth=false \
  --cgroup-driver systemd \
  --cluster-dns 192.168.0.2 \
  --node-ip 192.168.14.21 \
  --cluster-domain cluster.local \
  --runtime-cgroups=/systemd/system.slice \
  --kubelet-cgroups=/systemd/system.slice \
  --fail-swap-on="false" \
  --client-ca-file ./certs/ca.pem \
  --tls-cert-file ./certs/kubelet.pem \
  --tls-private-key-file ./certs/kubelet-key.pem \
  --hostname-override kb21 \
  --image-gc-high-threshold 20 \
  --image-gc-low-threshold 10 \
  --kubeconfig ./conf/kubelet.kubeconfig \
  --log-dir /data/logs/kubenetes/kube-kubelet \
  --pod-infra-container-image kubernetes/pause:latest \
  --root-dir /data/kubelet
```



添加可执行权限
```shell
chmod +x kubelet.sh
```


参数说明：

`anonymous-auth=false`: 不能使用匿名登录

`cgroup-driver systemd`: 要与docker保持一致

`cluster-dns`: 集群的dns，这里先固定写，后续会提到

`node-ip`: 节点ip，和主机ip一致

`fail-swap-on="false"`: k8s运算时最好把swap关闭掉，但我们其他程序可能需要，所以添加该选项，会兼容swap存在的场景

`client-ca-file`:根证书

`tls-cert-file`:kubelet作为服务端需要的证书

`tls-private-key-file`:kubelet作为服务端需要的证书私钥

`hostname-override`: 主机名称

`kubeconfig`: kubelet配置文件路径

`log-dir`: 日志目录

`pod-infra-container-image`: 基础的pause镜像



创建数据目录和日志目录

```shell
# 创建日志目录
mkdir -p /data/logs/kubernetes/kube-kubelet
# 创建数据目录
mkdir -p /data/kubelet
```


创建supervisor进程配置文件`/etc/supervisord.d/kube-kubelet.ini`文件，添加以下内容

```shell
[program:kube-kubelet-21]
directory=/opt/kubernetes/server/bin
command=/opt/kubernetes/server/bin/kubelet.sh
numprocs=1
autostart=true
autorestart=true
startsecs=30
startretries=3
exitcodes=0,2
stopsignal=QUIT
stopwaitsecs=10
user=root
redirect_stderr=true
stdout_logfile=/data/logs/kubernetes/kube-kubelet/kubelet.stdout.log
stdout_logfile_maxbytes=64MB
stdout_logfile_backups=4
stdout_capture_maxbytes=1MB
stdout_event_enabled=false
```

给脚本添加可执行权限

```shell
chmod +x kubelet.sh
```


更新supervisord，如下命令

```shell-script
supervisorctl update
```


此时，服务已经正常运行了，可以使用以下命令查看节点信息

```shell
kubectl get nodes
```


如果看到以下信息，代表安装成功

```shell
[root@kb21 bin]# kubectl get nodes
NAME   STATUS   ROLES    AGE    VERSION
kb21   Ready    <none>   5m2s   v1.15.2
kb22   Ready    <none>   5m2s   v1.15.2
```

我们还可以设置集群的标签

```shell
# 设置集群为master标签
kubectl label node kb21 node-role.kubernetes.io/master=
kubectl label node kb22 node-role.kubernetes.io/master=
# 设置集群为node标签
kubectl label node kb21 node-role.kubernetes.io/node=
kubectl label node kb22 node-role.kubernetes.io/node=
```







